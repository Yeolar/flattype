// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MATRIX_FTT_FBS_H_
#define FLATBUFFERS_GENERATED_MATRIX_FTT_FBS_H_

#include "flatbuffers/flatbuffers.h"

#include "base_generated.h"

namespace ftt {
namespace fbs {

struct Tuple;

struct Item;

struct Record;

struct Matrix;

enum Any {
  Any_NONE = 0,
  Any_Null = 1,
  Any_Bool = 2,
  Any_Int8 = 3,
  Any_Int16 = 4,
  Any_Int32 = 5,
  Any_Int64 = 6,
  Any_UInt8 = 7,
  Any_UInt16 = 8,
  Any_UInt32 = 9,
  Any_UInt64 = 10,
  Any_Float = 11,
  Any_Double = 12,
  Any_String = 13,
  Any_BoolArray = 14,
  Any_Int8Array = 15,
  Any_Int16Array = 16,
  Any_Int32Array = 17,
  Any_Int64Array = 18,
  Any_UInt8Array = 19,
  Any_UInt16Array = 20,
  Any_UInt32Array = 21,
  Any_UInt64Array = 22,
  Any_FloatArray = 23,
  Any_DoubleArray = 24,
  Any_StringArray = 25,
  Any_Tuple = 26,
  Any_MIN = Any_NONE,
  Any_MAX = Any_Tuple
};

inline Any (&EnumValuesAny())[27] {
  static Any values[] = {
    Any_NONE,
    Any_Null,
    Any_Bool,
    Any_Int8,
    Any_Int16,
    Any_Int32,
    Any_Int64,
    Any_UInt8,
    Any_UInt16,
    Any_UInt32,
    Any_UInt64,
    Any_Float,
    Any_Double,
    Any_String,
    Any_BoolArray,
    Any_Int8Array,
    Any_Int16Array,
    Any_Int32Array,
    Any_Int64Array,
    Any_UInt8Array,
    Any_UInt16Array,
    Any_UInt32Array,
    Any_UInt64Array,
    Any_FloatArray,
    Any_DoubleArray,
    Any_StringArray,
    Any_Tuple
  };
  return values;
}

inline const char **EnumNamesAny() {
  static const char *names[] = {
    "NONE",
    "Null",
    "Bool",
    "Int8",
    "Int16",
    "Int32",
    "Int64",
    "UInt8",
    "UInt16",
    "UInt32",
    "UInt64",
    "Float",
    "Double",
    "String",
    "BoolArray",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Int64Array",
    "UInt8Array",
    "UInt16Array",
    "UInt32Array",
    "UInt64Array",
    "FloatArray",
    "DoubleArray",
    "StringArray",
    "Tuple",
    nullptr
  };
  return names;
}

inline const char *EnumNameAny(Any e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAny()[index];
}

template<typename T> struct AnyTraits {
  static const Any enum_value = Any_NONE;
};

template<> struct AnyTraits<ftt::fbs::Null> {
  static const Any enum_value = Any_Null;
};

template<> struct AnyTraits<ftt::fbs::Bool> {
  static const Any enum_value = Any_Bool;
};

template<> struct AnyTraits<ftt::fbs::Int8> {
  static const Any enum_value = Any_Int8;
};

template<> struct AnyTraits<ftt::fbs::Int16> {
  static const Any enum_value = Any_Int16;
};

template<> struct AnyTraits<ftt::fbs::Int32> {
  static const Any enum_value = Any_Int32;
};

template<> struct AnyTraits<ftt::fbs::Int64> {
  static const Any enum_value = Any_Int64;
};

template<> struct AnyTraits<ftt::fbs::UInt8> {
  static const Any enum_value = Any_UInt8;
};

template<> struct AnyTraits<ftt::fbs::UInt16> {
  static const Any enum_value = Any_UInt16;
};

template<> struct AnyTraits<ftt::fbs::UInt32> {
  static const Any enum_value = Any_UInt32;
};

template<> struct AnyTraits<ftt::fbs::UInt64> {
  static const Any enum_value = Any_UInt64;
};

template<> struct AnyTraits<ftt::fbs::Float> {
  static const Any enum_value = Any_Float;
};

template<> struct AnyTraits<ftt::fbs::Double> {
  static const Any enum_value = Any_Double;
};

template<> struct AnyTraits<ftt::fbs::String> {
  static const Any enum_value = Any_String;
};

template<> struct AnyTraits<ftt::fbs::BoolArray> {
  static const Any enum_value = Any_BoolArray;
};

template<> struct AnyTraits<ftt::fbs::Int8Array> {
  static const Any enum_value = Any_Int8Array;
};

template<> struct AnyTraits<ftt::fbs::Int16Array> {
  static const Any enum_value = Any_Int16Array;
};

template<> struct AnyTraits<ftt::fbs::Int32Array> {
  static const Any enum_value = Any_Int32Array;
};

template<> struct AnyTraits<ftt::fbs::Int64Array> {
  static const Any enum_value = Any_Int64Array;
};

template<> struct AnyTraits<ftt::fbs::UInt8Array> {
  static const Any enum_value = Any_UInt8Array;
};

template<> struct AnyTraits<ftt::fbs::UInt16Array> {
  static const Any enum_value = Any_UInt16Array;
};

template<> struct AnyTraits<ftt::fbs::UInt32Array> {
  static const Any enum_value = Any_UInt32Array;
};

template<> struct AnyTraits<ftt::fbs::UInt64Array> {
  static const Any enum_value = Any_UInt64Array;
};

template<> struct AnyTraits<ftt::fbs::FloatArray> {
  static const Any enum_value = Any_FloatArray;
};

template<> struct AnyTraits<ftt::fbs::DoubleArray> {
  static const Any enum_value = Any_DoubleArray;
};

template<> struct AnyTraits<ftt::fbs::StringArray> {
  static const Any enum_value = Any_StringArray;
};

template<> struct AnyTraits<Tuple> {
  static const Any enum_value = Any_Tuple;
};

bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type);
bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  const flatbuffers::Vector<uint8_t> *value_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *value() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE_TYPE) &&
           verifier.Verify(value_type()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           VerifyAnyVector(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value_type) {
    fbb_.AddOffset(Tuple::VT_VALUE_TYPE, value_type);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> value) {
    fbb_.AddOffset(Tuple::VT_VALUE, value);
  }
  TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TupleBuilder &operator=(const TupleBuilder &);
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> value = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tuple> CreateTupleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *value = nullptr) {
  return ftt::fbs::CreateTuple(
      _fbb,
      value_type ? _fbb.CreateVector<uint8_t>(*value_type) : 0,
      value ? _fbb.CreateVector<flatbuffers::Offset<void>>(*value) : 0);
}

struct Item FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  Any value_type() const {
    return static_cast<Any>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ftt::fbs::Null *value_as_Null() const {
    return value_type() == Any_Null ? static_cast<const ftt::fbs::Null *>(value()) : nullptr;
  }
  const ftt::fbs::Bool *value_as_Bool() const {
    return value_type() == Any_Bool ? static_cast<const ftt::fbs::Bool *>(value()) : nullptr;
  }
  const ftt::fbs::Int8 *value_as_Int8() const {
    return value_type() == Any_Int8 ? static_cast<const ftt::fbs::Int8 *>(value()) : nullptr;
  }
  const ftt::fbs::Int16 *value_as_Int16() const {
    return value_type() == Any_Int16 ? static_cast<const ftt::fbs::Int16 *>(value()) : nullptr;
  }
  const ftt::fbs::Int32 *value_as_Int32() const {
    return value_type() == Any_Int32 ? static_cast<const ftt::fbs::Int32 *>(value()) : nullptr;
  }
  const ftt::fbs::Int64 *value_as_Int64() const {
    return value_type() == Any_Int64 ? static_cast<const ftt::fbs::Int64 *>(value()) : nullptr;
  }
  const ftt::fbs::UInt8 *value_as_UInt8() const {
    return value_type() == Any_UInt8 ? static_cast<const ftt::fbs::UInt8 *>(value()) : nullptr;
  }
  const ftt::fbs::UInt16 *value_as_UInt16() const {
    return value_type() == Any_UInt16 ? static_cast<const ftt::fbs::UInt16 *>(value()) : nullptr;
  }
  const ftt::fbs::UInt32 *value_as_UInt32() const {
    return value_type() == Any_UInt32 ? static_cast<const ftt::fbs::UInt32 *>(value()) : nullptr;
  }
  const ftt::fbs::UInt64 *value_as_UInt64() const {
    return value_type() == Any_UInt64 ? static_cast<const ftt::fbs::UInt64 *>(value()) : nullptr;
  }
  const ftt::fbs::Float *value_as_Float() const {
    return value_type() == Any_Float ? static_cast<const ftt::fbs::Float *>(value()) : nullptr;
  }
  const ftt::fbs::Double *value_as_Double() const {
    return value_type() == Any_Double ? static_cast<const ftt::fbs::Double *>(value()) : nullptr;
  }
  const ftt::fbs::String *value_as_String() const {
    return value_type() == Any_String ? static_cast<const ftt::fbs::String *>(value()) : nullptr;
  }
  const ftt::fbs::BoolArray *value_as_BoolArray() const {
    return value_type() == Any_BoolArray ? static_cast<const ftt::fbs::BoolArray *>(value()) : nullptr;
  }
  const ftt::fbs::Int8Array *value_as_Int8Array() const {
    return value_type() == Any_Int8Array ? static_cast<const ftt::fbs::Int8Array *>(value()) : nullptr;
  }
  const ftt::fbs::Int16Array *value_as_Int16Array() const {
    return value_type() == Any_Int16Array ? static_cast<const ftt::fbs::Int16Array *>(value()) : nullptr;
  }
  const ftt::fbs::Int32Array *value_as_Int32Array() const {
    return value_type() == Any_Int32Array ? static_cast<const ftt::fbs::Int32Array *>(value()) : nullptr;
  }
  const ftt::fbs::Int64Array *value_as_Int64Array() const {
    return value_type() == Any_Int64Array ? static_cast<const ftt::fbs::Int64Array *>(value()) : nullptr;
  }
  const ftt::fbs::UInt8Array *value_as_UInt8Array() const {
    return value_type() == Any_UInt8Array ? static_cast<const ftt::fbs::UInt8Array *>(value()) : nullptr;
  }
  const ftt::fbs::UInt16Array *value_as_UInt16Array() const {
    return value_type() == Any_UInt16Array ? static_cast<const ftt::fbs::UInt16Array *>(value()) : nullptr;
  }
  const ftt::fbs::UInt32Array *value_as_UInt32Array() const {
    return value_type() == Any_UInt32Array ? static_cast<const ftt::fbs::UInt32Array *>(value()) : nullptr;
  }
  const ftt::fbs::UInt64Array *value_as_UInt64Array() const {
    return value_type() == Any_UInt64Array ? static_cast<const ftt::fbs::UInt64Array *>(value()) : nullptr;
  }
  const ftt::fbs::FloatArray *value_as_FloatArray() const {
    return value_type() == Any_FloatArray ? static_cast<const ftt::fbs::FloatArray *>(value()) : nullptr;
  }
  const ftt::fbs::DoubleArray *value_as_DoubleArray() const {
    return value_type() == Any_DoubleArray ? static_cast<const ftt::fbs::DoubleArray *>(value()) : nullptr;
  }
  const ftt::fbs::StringArray *value_as_StringArray() const {
    return value_type() == Any_StringArray ? static_cast<const ftt::fbs::StringArray *>(value()) : nullptr;
  }
  const Tuple *value_as_Tuple() const {
    return value_type() == Any_Tuple ? static_cast<const Tuple *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyAny(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ftt::fbs::Null *Item::value_as<ftt::fbs::Null>() const {
  return value_as_Null();
}

template<> inline const ftt::fbs::Bool *Item::value_as<ftt::fbs::Bool>() const {
  return value_as_Bool();
}

template<> inline const ftt::fbs::Int8 *Item::value_as<ftt::fbs::Int8>() const {
  return value_as_Int8();
}

template<> inline const ftt::fbs::Int16 *Item::value_as<ftt::fbs::Int16>() const {
  return value_as_Int16();
}

template<> inline const ftt::fbs::Int32 *Item::value_as<ftt::fbs::Int32>() const {
  return value_as_Int32();
}

template<> inline const ftt::fbs::Int64 *Item::value_as<ftt::fbs::Int64>() const {
  return value_as_Int64();
}

template<> inline const ftt::fbs::UInt8 *Item::value_as<ftt::fbs::UInt8>() const {
  return value_as_UInt8();
}

template<> inline const ftt::fbs::UInt16 *Item::value_as<ftt::fbs::UInt16>() const {
  return value_as_UInt16();
}

template<> inline const ftt::fbs::UInt32 *Item::value_as<ftt::fbs::UInt32>() const {
  return value_as_UInt32();
}

template<> inline const ftt::fbs::UInt64 *Item::value_as<ftt::fbs::UInt64>() const {
  return value_as_UInt64();
}

template<> inline const ftt::fbs::Float *Item::value_as<ftt::fbs::Float>() const {
  return value_as_Float();
}

template<> inline const ftt::fbs::Double *Item::value_as<ftt::fbs::Double>() const {
  return value_as_Double();
}

template<> inline const ftt::fbs::String *Item::value_as<ftt::fbs::String>() const {
  return value_as_String();
}

template<> inline const ftt::fbs::BoolArray *Item::value_as<ftt::fbs::BoolArray>() const {
  return value_as_BoolArray();
}

template<> inline const ftt::fbs::Int8Array *Item::value_as<ftt::fbs::Int8Array>() const {
  return value_as_Int8Array();
}

template<> inline const ftt::fbs::Int16Array *Item::value_as<ftt::fbs::Int16Array>() const {
  return value_as_Int16Array();
}

template<> inline const ftt::fbs::Int32Array *Item::value_as<ftt::fbs::Int32Array>() const {
  return value_as_Int32Array();
}

template<> inline const ftt::fbs::Int64Array *Item::value_as<ftt::fbs::Int64Array>() const {
  return value_as_Int64Array();
}

template<> inline const ftt::fbs::UInt8Array *Item::value_as<ftt::fbs::UInt8Array>() const {
  return value_as_UInt8Array();
}

template<> inline const ftt::fbs::UInt16Array *Item::value_as<ftt::fbs::UInt16Array>() const {
  return value_as_UInt16Array();
}

template<> inline const ftt::fbs::UInt32Array *Item::value_as<ftt::fbs::UInt32Array>() const {
  return value_as_UInt32Array();
}

template<> inline const ftt::fbs::UInt64Array *Item::value_as<ftt::fbs::UInt64Array>() const {
  return value_as_UInt64Array();
}

template<> inline const ftt::fbs::FloatArray *Item::value_as<ftt::fbs::FloatArray>() const {
  return value_as_FloatArray();
}

template<> inline const ftt::fbs::DoubleArray *Item::value_as<ftt::fbs::DoubleArray>() const {
  return value_as_DoubleArray();
}

template<> inline const ftt::fbs::StringArray *Item::value_as<ftt::fbs::StringArray>() const {
  return value_as_StringArray();
}

template<> inline const Tuple *Item::value_as<Tuple>() const {
  return value_as_Tuple();
}

struct ItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(Any value_type) {
    fbb_.AddElement<uint8_t>(Item::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Item::VT_VALUE, value);
  }
  ItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemBuilder &operator=(const ItemBuilder &);
  flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline flatbuffers::Offset<Item> CreateItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    Any value_type = Any_NONE,
    flatbuffers::Offset<void> value = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct Record FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Item>> *value() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Item>> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.VerifyVectorOfTables(value()) &&
           verifier.EndTable();
  }
};

struct RecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Item>>> value) {
    fbb_.AddOffset(Record::VT_VALUE, value);
  }
  RecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecordBuilder &operator=(const RecordBuilder &);
  flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline flatbuffers::Offset<Record> CreateRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Item>>> value = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<Record> CreateRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Item>> *value = nullptr) {
  return ftt::fbs::CreateRecord(
      _fbb,
      value ? _fbb.CreateVector<flatbuffers::Offset<Item>>(*value) : 0);
}

struct Matrix FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Record>> *value() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Record>> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.VerifyVectorOfTables(value()) &&
           verifier.EndTable();
  }
};

struct MatrixBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Record>>> value) {
    fbb_.AddOffset(Matrix::VT_VALUE, value);
  }
  MatrixBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixBuilder &operator=(const MatrixBuilder &);
  flatbuffers::Offset<Matrix> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Matrix>(end);
    return o;
  }
};

inline flatbuffers::Offset<Matrix> CreateMatrix(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Record>>> value = 0) {
  MatrixBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<Matrix> CreateMatrixDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Record>> *value = nullptr) {
  return ftt::fbs::CreateMatrix(
      _fbb,
      value ? _fbb.CreateVector<flatbuffers::Offset<Record>>(*value) : 0);
}

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type) {
  switch (type) {
    case Any_NONE: {
      return true;
    }
    case Any_Null: {
      auto ptr = reinterpret_cast<const ftt::fbs::Null *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Bool: {
      auto ptr = reinterpret_cast<const ftt::fbs::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Int8: {
      auto ptr = reinterpret_cast<const ftt::fbs::Int8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Int16: {
      auto ptr = reinterpret_cast<const ftt::fbs::Int16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Int32: {
      auto ptr = reinterpret_cast<const ftt::fbs::Int32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Int64: {
      auto ptr = reinterpret_cast<const ftt::fbs::Int64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_UInt8: {
      auto ptr = reinterpret_cast<const ftt::fbs::UInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_UInt16: {
      auto ptr = reinterpret_cast<const ftt::fbs::UInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_UInt32: {
      auto ptr = reinterpret_cast<const ftt::fbs::UInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_UInt64: {
      auto ptr = reinterpret_cast<const ftt::fbs::UInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Float: {
      auto ptr = reinterpret_cast<const ftt::fbs::Float *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Double: {
      auto ptr = reinterpret_cast<const ftt::fbs::Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_String: {
      auto ptr = reinterpret_cast<const ftt::fbs::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_BoolArray: {
      auto ptr = reinterpret_cast<const ftt::fbs::BoolArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Int8Array: {
      auto ptr = reinterpret_cast<const ftt::fbs::Int8Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Int16Array: {
      auto ptr = reinterpret_cast<const ftt::fbs::Int16Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Int32Array: {
      auto ptr = reinterpret_cast<const ftt::fbs::Int32Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Int64Array: {
      auto ptr = reinterpret_cast<const ftt::fbs::Int64Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_UInt8Array: {
      auto ptr = reinterpret_cast<const ftt::fbs::UInt8Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_UInt16Array: {
      auto ptr = reinterpret_cast<const ftt::fbs::UInt16Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_UInt32Array: {
      auto ptr = reinterpret_cast<const ftt::fbs::UInt32Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_UInt64Array: {
      auto ptr = reinterpret_cast<const ftt::fbs::UInt64Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_FloatArray: {
      auto ptr = reinterpret_cast<const ftt::fbs::FloatArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_DoubleArray: {
      auto ptr = reinterpret_cast<const ftt::fbs::DoubleArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_StringArray: {
      auto ptr = reinterpret_cast<const ftt::fbs::StringArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Tuple: {
      auto ptr = reinterpret_cast<const Tuple *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAny(
        verifier,  values->Get(i), types->GetEnum<Any>(i))) {
      return false;
    }
  }
  return true;
}

inline const ftt::fbs::Matrix *GetMatrix(const void *buf) {
  return flatbuffers::GetRoot<ftt::fbs::Matrix>(buf);
}

inline bool VerifyMatrixBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ftt::fbs::Matrix>(nullptr);
}

inline void FinishMatrixBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ftt::fbs::Matrix> root) {
  fbb.Finish(root);
}

}  // namespace fbs
}  // namespace ftt

#endif  // FLATBUFFERS_GENERATED_MATRIX_FTT_FBS_H_
