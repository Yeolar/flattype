/*
 * Copyright 2018 Yeolar
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <flatbuffers/flatbuffers.h>

#include "flatjson/idl/json_generated.h"

namespace flatjson {

typedef fbs::Type Type;

struct TypeError : std::runtime_error {
  explicit TypeError(const std::string& expected, Type actual);
  explicit TypeError(const std::string& expected, Type actual1, Type actual2);
  ~TypeError();
};

class JSON {
 public:
  typedef ::flatbuffers::Vector<::flatbuffers::Offset<void>>::const_iterator
    const_iterator;

  JSON(const uint8_t* data = nullptr);

  JSON(const JSON&) = delete;
  JSON& operator=(const JSON&) = delete;

  JSON(JSON&&) = default;
  JSON& operator=(JSON&&) = default;

  bool operator==(const JSON& o) const;
  bool operator<(const JSON& o) const;

  fbs::Type type() const { return data_->value_type(); }

  const char* typeName() const {
    return fbs::EnumNameType(type());
  }

  bool isNull()   const { return type() == fbs::Type_Null; }
  bool isBool()   const { return type() == fbs::Type_Bool; }
  bool isInt()    const { return type() == fbs::Type_Int64; }
  bool isDouble() const { return type() == fbs::Type_Double; }
  bool isString() const { return type() == fbs::Type_String; }
  bool isArray()  const { return type() == fbs::Type_Array; }
  bool isObject() const { return type() == fbs::Type_Object; }

  bool isNumber() const { return isInt() || isDouble(); }

  bool        asBool()   const { return asImpl<bool>(); }
  int64_t     asInt()    const { return asImpl<int64_t>(); }
  double      asDouble() const { return asImpl<double>(); }
  std::string asString() const { return asImpl<std::string>(); }

  bool               getBool()   const& { return get<bool>(); }
  int64_t            getInt()    const& { return get<int64_t>(); }
  double             getDouble() const& { return get<double>(); }
  const std::string& getString() const& { return get<std::string>(); }

  bool&        getBool() &   { return get<bool>(); }
  int64_t&     getInt() &    { return get<int64_t>(); }
  double&      getDouble() & { return get<double>(); }
  std::string& getString() & { return get<std::string>(); }

  bool          getBool() &&   { return get<bool>(); }
  int64_t       getInt() &&    { return get<int64_t>(); }
  double        getDouble() && { return get<double>(); }
  std::string&& getString() && { return std::move(get<std::string>()); }

  bool empty() const {
    if (isNull()) {
      return true;
    }
    return !size();
  }

  std::size_t size() const {
    switch (type()) {
      case fbs::Type_Array:
        return data_->value_as_Array()->value()->size();
      case fbs::Type_Object:
        return data_->value_as_Object()->value()->size();
      case fbs::Type_String:
        return data_->value_as_String()->value()->size();
      default:
        throw TypeError("array/object", type());
    }
  }

  const_iterator begin() const {
    return data_->value_as_Array()->value()->begin();
  }
  const_iterator end() const {
    return data_->value_as_Array()->value()->end();
  }

 private:
  /*
   * Helper object returned by keys(), values(), and items().
   */
  template <class T> struct IterableProxy;

 public:
  /*
   * You can iterate over the keys, values, or items (std::pair of key and
   * value) in an object.  Calling these on non-objects will throw a TypeError.
   */
  IterableProxy<const_key_iterator> keys() const;
  IterableProxy<const_value_iterator> values() const;
  IterableProxy<const_item_iterator> items() const;

  /*
   * AssociativeContainer-style find interface for objects.  Throws if
   * this is not an object.
   *
   * Returns: items().end() if the key is not present, or a
   * const_item_iterator pointing to the item.
   */
  const_item_iterator find(JSON const&) const;

  /*
   * If this is an object, returns whether it contains a field with
   * the given name.  Otherwise throws TypeError.
   */
  std::size_t count(JSON const&) const;

  /*
   * For objects or arrays, provides access to sub-fields by index or
   * field name.
   *
   * Using these with JSON objects that are not arrays or objects
   * will throw a TypeError.  Using an index that is out of range or
   * object-element that's not present throws std::out_of_range.
   */
  JSON const& at(JSON const&) const&;
  JSON&       at(JSON const&) &;
  JSON&&      at(JSON const&) &&;

  /*
   * Like 'at', above, except it returns either a pointer to the contained
   * object or nullptr if it wasn't found. This allows a key to be tested for
   * containment and retrieved in one operation. Example:
   *
   *   if (auto* found = d.get_ptr(key))
   *     // use *found;
   *
   * Using these with JSON objects that are not arrays or objects
   * will throw a TypeError.
   */
  const JSON* get_ptr(JSON const&) const&;
  JSON* get_ptr(JSON const&) &;
  JSON* get_ptr(JSON const&) && = delete;

  /*
   * This works for access to both objects and arrays.
   *
   * In the case of an array, the index must be an integer, and this will throw
   * std::out_of_range if it is less than zero or greater than size().
   *
   * In the case of an object, the non-const overload inserts a null
   * value if the key isn't present.  The const overload will throw
   * std::out_of_range if the key is not present.
   *
   * These functions do not invalidate iterators.
   */
  JSON&       operator[](JSON const&) &;
  JSON const& operator[](JSON const&) const&;
  JSON&&      operator[](JSON const&) &&;

  /*
   * Only defined for objects, throws TypeError otherwise.
   *
   * getDefault will return the value associated with the supplied key, the
   * supplied default otherwise. setDefault will set the key to the supplied
   * default if it is not yet set, otherwise leaving it. setDefault returns
   * a reference to the existing value if present, the new value otherwise.
   */
  JSON
  getDefault(const JSON& k, const JSON& v = JSON::object) const&;
  JSON getDefault(const JSON& k, JSON&& v) const&;
  JSON getDefault(const JSON& k, const JSON& v = JSON::object) &&;
  JSON getDefault(const JSON& k, JSON&& v) &&;

 private:
  friend struct TypeError;

  struct ObjectImpl;
  template<class T> struct TypeInfo;
  template<class T> struct CompareOp;
  template<class T> struct GetAddrImpl;
  template<class T> struct PrintImpl;

  explicit JSON(Array&& array);

  template<class T> T&       get() {
    if (auto* p = get_nothrow<T>()) {
      return *p;
    }
    throw TypeError(TypeInfo<T>::name, type());
  }
  template<class T> T const& get() const {
    return const_cast<JSON*>(this)->get<T>();
  }

  template<class T> T*       get_nothrow() & noexcept {
    if (type() != TypeInfo<T>::type) {
      return nullptr;
    }
    return getAddress<T>();
  }
  template<class T> T const* get_nothrow() const& noexcept {
    return const_cast<JSON*>(this)->get_nothrow<T>();
  }

  template<class T> T*       get_nothrow() && noexcept = delete;
  template<class T> T*       getAddress() noexcept;
  template<class T> T const* getAddress() const noexcept;

  template<class T> T asImpl() const;

  static char const* typeName(Type);
  void destroy() noexcept;
  void print(std::ostream&) const;
  void print_as_pseudo_json(std::ostream&) const; // see json.cpp

 private:
  const fbs::JSON* data_;
};

} // namespace flatjson
